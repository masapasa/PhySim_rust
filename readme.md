The simulation uses the vorticity-streamfunction formulation for the 2D incompressible Navier-Stokes equations coupled with a heat transport equation. This is a standard and effective method for this type of problem.

![arcitecture](rst_pinn.png)

### 1. Project Structure

Your project will look like this:

```
.
├── Cargo.toml
├── .env
├── migrations/
│   └── 00000000000000_create_initial_tables/
│       ├── up.sql
│       └── down.sql
└── src/
    ├── main.rs
    ├── simulation.rs
    ├── db.rs
    ├── models.rs
    ├── schema.rs
    └── visualization.rs
```

---

### 2. Setup Instructions

**1. Install Dependencies:**
   - **Rust:** Install from [rust-lang.org](https://www.rust-lang.org/).
   - **PostgreSQL:** Install a local PostgreSQL server.
   - **Diesel CLI:** This is required to manage the database schema.
     ```bash
     cargo install diesel_cli --no-default-features --features postgres
     ```

**2. Setup Database:**
   - Open `psql` or your favorite DB client and create a database.
     ```sql
     CREATE DATABASE cfd_cz_growth;
     ```
   - Create a `.env` file in your project root with the connection URL:
     ```
     # .env
     DATABASE_URL=postgres://your_user:your_password@localhost/cfd_cz_growth
     ```
     Replace `your_user` and `your_password` with your PostgreSQL credentials.

**3. Create and Run Migrations:**
   - Create the migration files:
     ```bash
     diesel migration generate create_initial_tables
     ```
   - This creates the `migrations/...` directory.

**4. Populate `up.sql` and `down.sql`:**
   - **`migrations/.../up.sql`:**
     ```sql
     -- Your SQL to create the tables
     CREATE TABLE simulation_runs (
         id SERIAL PRIMARY KEY,
         description TEXT NOT NULL,
         grid_size INTEGER NOT NULL,
         time_steps INTEGER NOT NULL,
         prandtl_number DOUBLE PRECISION NOT NULL,
         rayleigh_number DOUBLE PRECISION NOT NULL,
         created_at TIMESTAMP NOT NULL DEFAULT NOW()
     );

     CREATE TABLE results (
         id BIGSERIAL PRIMARY KEY,
         run_id INTEGER NOT NULL REFERENCES simulation_runs(id) ON DELETE CASCADE,
         x INTEGER NOT NULL,
         y INTEGER NOT NULL,
         temperature DOUBLE PRECISION NOT NULL,
         u_velocity DOUBLE PRECISION NOT NULL,
         v_velocity DOUBLE PRECISION NOT NULL
     );

     CREATE INDEX idx_results_run_id ON results (run_id);
     ```
   - **`migrations/.../down.sql`:**
     ```sql
     -- Your SQL to drop the tables
     DROP TABLE results;
     DROP TABLE simulation_runs;
     ```

**5. Run the migration:**
   ```bash
   diesel migration run
   ```

**6. Generate `schema.rs`:**
   - Diesel uses this file to understand your database schema in a type-safe way.
   ```bash
   diesel print-schema > src/schema.rs
   ```

Now you are ready to add the code.

---

### 3. `Cargo.toml`

```toml
[package]
name = "cz_cfd_simulator"
version = "0.1.0"
edition = "2021"

[dependencies]
# Core numerical library for grid operations
ndarray = "0.15"

# Database ORM and connection pooling
diesel = { version = "2.1.0", features = ["postgres", "r2d2", "chrono"] }
r2d2 = "0.8.10"
dotenvy = "0.15"

# Command-line interface
clap = { version = "4.4.8", features = ["derive"] }

# 2D Plotting for visualization
plotters = "0.3.5"

# Timestamps
chrono = { version = "0.4", features = ["serde"] }

# Error handling
anyhow = "1.0"
```

---

### 4. Rust Source Code

#### `src/schema.rs` (Auto-generated)
This file is generated by the `diesel print-schema` command. It will look like this:

```rust
// @generated automatically by Diesel CLI.

diesel::table! {
    results (id) {
        id -> Int8,
        run_id -> Int4,
        x -> Int4,
        y -> Int4,
        temperature -> Float8,
        u_velocity -> Float8,
        v_velocity -> Float8,
    }
}

diesel::table! {
    simulation_runs (id) {
        id -> Int4,
        description -> Text,
        grid_size -> Int4,
        time_steps -> Int4,
        prandtl_number -> Float8,
        rayleigh_number -> Float8,
        created_at -> Timestamp,
    }
}

diesel::joinable!(results -> simulation_runs (run_id));

diesel::allow_tables_to_appear_in_same_query!(
    results,
    simulation_runs,
);
```

#### `src/models.rs`

```rust
use crate::schema::{results, simulation_runs};
use diesel::prelude::*;
use chrono::NaiveDateTime;

#[derive(Queryable, Identifiable, Selectable, Debug)]
#[diesel(table_name = simulation_runs)]
pub struct SimulationRun {
    pub id: i32,
    pub description: String,
    pub grid_size: i32,
    pub time_steps: i32,
    pub prandtl_number: f64,
    pub rayleigh_number: f64,
    pub created_at: NaiveDateTime,
}

#[derive(Insertable)]
#[diesel(table_name = simulation_runs)]
pub struct NewSimulationRun<'a> {
    pub description: &'a str,
    pub grid_size: i32,
    pub time_steps: i32,
    pub prandtl_number: f64,
    pub rayleigh_number: f64,
}

#[derive(Insertable)]
#[diesel(table_name = results)]
pub struct NewResultPoint {
    pub run_id: i32,
    pub x: i32,
    pub y: i32,
    pub temperature: f64,
    pub u_velocity: f64,
    pub v_velocity: f64,
}
```

#### `src/simulation.rs`

```rust
use ndarray::{Array, Array2, Axis};

// Holds the parameters for a simulation run.
pub struct SimParameters {
    pub nx: usize, // Number of grid points in x
    pub ny: usize, // Number of grid points in y
    pub dt: f64,   // Time step
    pub pr: f64,   // Prandtl number
    pub ra: f64,   // Rayleigh number
}

// Holds the state of the simulation at a given time.
pub struct SimState {
    pub temp: Array2<f64>,        // Temperature
    pub vort: Array2<f64>,        // Vorticity
    pub stream: Array2<f64>,      // Stream function
    pub u: Array2<f64>,           // X-velocity
    pub v: Array2<f64>,           // Y-velocity
}

impl SimState {
    pub fn new(nx: usize, ny: usize) -> Self {
        SimState {
            temp: Array::zeros((ny, nx)),
            vort: Array::zeros((ny, nx)),
            stream: Array::zeros((ny, nx)),
            u: Array::zeros((ny, nx)),
            v: Array::zeros((ny, nx)),
        }
    }
}

// Main simulation controller.
pub struct Simulation {
    pub params: SimParameters,
    pub state: SimState,
    dx: f64,
    dy: f64,
}

impl Simulation {
    pub fn new(params: SimParameters) -> Self {
        let mut sim = Simulation {
            dx: 1.0 / (params.nx as f64 - 1.0),
            dy: 1.0 / (params.ny as f64 - 1.0),
            state: SimState::new(params.nx, params.ny),
            params,
        };
        sim.initialize_conditions();
        sim
    }

    // Set initial and boundary conditions.
    fn initialize_conditions(&mut self) {
        let (ny, nx) = self.state.temp.dim();
        // Boundary Conditions: Hot bottom/sides, cold top (the "crystal")
        self.state.temp.row_mut(0).fill(1.0); // Bottom wall
        self.state.temp.row_mut(ny - 1).fill(0.0); // Top wall
        self.state.temp.column_mut(0).fill(1.0); // Left wall
        self.state.temp.column_mut(nx-1).fill(1.0); // Right wall
    }

    // Perform one time step.
    pub fn step(&mut self) {
        let (ny, nx) = self.state.temp.dim();
        let dx = self.dx;
        let dy = self.dy;
        let dt = self.params.dt;

        let mut temp_new = self.state.temp.clone();
        let mut vort_new = self.state.vort.clone();

        // 1. Solve Stream Function (Poisson equation: ∇²ψ = -ω) using Jacobi iteration
        for _ in 0..50 { // Iterate to converge
            let stream_old = self.state.stream.clone();
            for i in 1..ny - 1 {
                for j in 1..nx - 1 {
                    self.state.stream[[i, j]] = ((stream_old[[i, j+1]] + stream_old[[i, j-1]]) * dy*dy +
                                                (stream_old[[i+1, j]] + stream_old[[i-1, j]]) * dx*dx -
                                                self.state.vort[[i, j]] * dx*dx*dy*dy) /
                                                (2.0 * (dx*dx + dy*dy));
                }
            }
        }

        // 2. Update Velocities (u = ∂ψ/∂y, v = -∂ψ/∂x)
        for i in 1..ny-1 {
            for j in 1..nx-1 {
                self.state.u[[i,j]] = (self.state.stream[[i+1, j]] - self.state.stream[[i-1, j]]) / (2.0*dy);
                self.state.v[[i,j]] = -(self.state.stream[[i, j+1]] - self.state.stream[[i, j-1]]) / (2.0*dx);
            }
        }

        // 3. Update Boundary Vorticity (Thom's formula for no-slip walls)
        for j in 1..nx-1 {
            // Bottom wall
            self.state.vort[[0, j]] = -2.0 * self.state.stream[[1, j]] / (dy*dy);
            // Top wall
            self.state.vort[[ny-1, j]] = -2.0 * self.state.stream[[ny-2, j]] / (dy*dy);
        }
        for i in 1..ny-1 {
            // Left wall
            self.state.vort[[i, 0]] = -2.0 * self.state.stream[[i, 1]] / (dx*dx);
            // Right wall
            self.state.vort[[i, nx-1]] = -2.0 * self.state.stream[[i, nx-2]] / (dx*dx);
        }

        // 4. Time-step Vorticity and Temperature (Advection-Diffusion equations)
        for i in 1..ny-1 {
            for j in 1..nx-1 {
                // Advection terms (using simple upwinding for stability)
                let u = self.state.u[[i,j]];
                let v = self.state.v[[i,j]];

                let vort_adv_x = if u > 0.0 { u * (self.state.vort[[i,j]] - self.state.vort[[i,j-1]]) / dx } else { u * (self.state.vort[[i,j+1]] - self.state.vort[[i,j]]) / dx };
                let vort_adv_y = if v > 0.0 { v * (self.state.vort[[i,j]] - self.state.vort[[i-1,j]]) / dy } else { v * (self.state.vort[[i,j+1]] - self.state.vort[[i,j]]) / dy };

                let temp_adv_x = if u > 0.0 { u * (self.state.temp[[i,j]] - self.state.temp[[i,j-1]]) / dx } else { u * (self.state.temp[[i,j+1]] - self.state.temp[[i,j]]) / dx };
                let temp_adv_y = if v > 0.0 { v * (self.state.temp[[i,j]] - self.state.temp[[i-1,j]]) / dy } else { v * (self.state.temp[[i,j+1]] - self.state.temp[[i,j]]) / dy };


                // Diffusion terms
                let vort_diff = self.params.pr * ( (self.state.vort[[i, j+1]] - 2.0*self.state.vort[[i,j]] + self.state.vort[[i,j-1]])/(dx*dx) + (self.state.vort[[i+1, j]] - 2.0*self.state.vort[[i,j]] + self.state.vort[[i-1, j]])/(dy*dy) );
                let temp_diff = (self.state.temp[[i, j+1]] - 2.0*self.state.temp[[i,j]] + self.state.temp[[i,j-1]])/(dx*dx) + (self.state.temp[[i+1, j]] - 2.0*self.state.temp[[i,j]] + self.state.temp[[i-1, j]])/(dy*dy);
                
                // Buoyancy term for vorticity
                let buoyancy = self.params.ra * self.params.pr * (self.state.temp[[i, j+1]] - self.state.temp[[i, j-1]]) / (2.0 * dx);

                // Update using Forward Euler
                vort_new[[i, j]] = self.state.vort[[i, j]] + dt * (vort_diff - vort_adv_x - vort_adv_y + buoyancy);
                temp_new[[i, j]] = self.state.temp[[i, j]] + dt * (temp_diff - temp_adv_x - temp_adv_y);
            }
        }
        self.state.vort = vort_new;
        self.state.temp = temp_new;
    }

    // Run the full simulation.
    pub fn run(&mut self, time_steps: usize) {
        for step in 0..time_steps {
            self.step();
            if step % 100 == 0 {
                println!("Completed step {}/{}", step, time_steps);
            }
        }
    }
}
```

#### `src/db.rs`

```rust
use diesel::pg::PgConnection;
use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};
use dotenvy::dotenv;
use std::env;
use anyhow::Result;

use crate::models::{NewResultPoint, NewSimulationRun, SimulationRun};
use crate::schema::{results, simulation_runs};
use crate::simulation::SimState;

pub type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;

pub fn establish_connection_pool() -> DbPool {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create pool.")
}

pub fn create_simulation_run(
    pool: &DbPool,
    desc: &str,
    grid_size: i32,
    time_steps: i32,
    pr: f64,
    ra: f64,
) -> Result<SimulationRun> {
    let mut conn = pool.get()?;
    let new_run = NewSimulationRun {
        description: desc,
        grid_size,
        time_steps,
        prandtl_number: pr,
        rayleigh_number: ra,
    };

    let run = diesel::insert_into(simulation_runs::table)
        .values(&new_run)
        .get_result(&mut conn)?;
    Ok(run)
}

pub fn save_simulation_results(
    pool: &DbPool,
    run_id: i32,
    final_state: &SimState,
) -> Result<()> {
    let mut conn = pool.get()?;
    let (ny, nx) = final_state.temp.dim();
    let mut new_points = Vec::new();

    for i in 0..ny {
        for j in 0..nx {
            new_points.push(NewResultPoint {
                run_id,
                x: j as i32,
                y: i as i32,
                temperature: final_state.temp[[i, j]],
                u_velocity: final_state.u[[i, j]],
                v_velocity: final_state.v[[i, j]],
            });
        }
    }

    // Use a bulk insert for performance
    diesel::insert_into(results::table)
        .values(&new_points)
        .execute(&mut conn)?;

    Ok(())
}

pub fn list_simulation_runs(pool: &DbPool) -> Result<()> {
    use crate::schema::simulation_runs::dsl::*;
    let mut conn = pool.get()?;
    let runs = simulation_runs.load::<SimulationRun>(&mut conn)?;

    println!("--- Available Simulation Runs ---");
    println!(
        "{:<5} | {:<25} | {:<10} | {:<10} | {:<10} | {:<10}",
        "ID", "Description", "Grid", "Steps", "Pr", "Ra"
    );
    println!("{}", "-".repeat(85));
    for run in runs {
        println!(
            "{:<5} | {:<25} | {:<10} | {:<10} | {:<10.2} | {:<10.1e}",
            run.id, run.description, run.grid_size, run.time_steps, run.prandtl_number, run.rayleigh_number
        );
    }
    Ok(())
}


pub fn get_simulation_results(pool: &DbPool, run_id_to_get: i32) -> Result<SimState> {
    use crate::schema::results::dsl::*;
    use crate::schema::simulation_runs::dsl::{grid_size, simulation_runs};

    let mut conn = pool.get()?;

    // First get grid size for the run
    let size = simulation_runs
        .find(run_id_to_get)
        .select(grid_size)
        .first::<i32>(&mut conn)?;
    
    let (nx, ny) = (size as usize, size as usize);
    let mut state = SimState::new(nx, ny);

    // Get all result points for the run
    let points = results
        .filter(run_id.eq(run_id_to_get))
        .load::<(i64, i32, i32, i32, f64, f64, f64)>(&mut conn)?;

    for point in points {
        let (_id, _run_id, x, y, temp, u_vel, v_vel) = point;
        if x < nx as i32 && y < ny as i32 {
            state.temp[[y as usize, x as usize]] = temp;
            state.u[[y as usize, x as usize]] = u_vel;
            state.v[[y as usize, x as usize]] = v_vel;
        }
    }

    Ok(state)
}
```

#### `src/visualization.rs`

```rust
use crate::simulation::SimState;
use anyhow::Result;
use plotters::prelude::*;

pub fn draw_temperature_map(state: &SimState, output_path: &str) -> Result<()> {
    let (ny, nx) = state.temp.dim();
    let root = BitMapBackend::new(output_path, (800, 700)).into_drawing_area();
    root.fill(&WHITE)?;

    let mut chart = ChartBuilder::on(&root)
        .title("Temperature Distribution", ("sans-serif", 30))
        .margin(20)
        .build_cartesian_2d(0..nx, 0..ny)?;

    chart
        .configure_mesh()
        .disable_x_mesh()
        .disable_y_mesh()
        .draw()?;

    // Create a heatmap
    chart.draw_series(
        (0..nx).flat_map(|x| (0..ny).map(move |y| (x, y, state.temp[[y, x]])))
        .map(|(x, y, temp)| {
            let color = HSLColor(240.0 * (1.0 - temp), 0.7, 0.5); // Blue (cold) to Red (hot)
            Rectangle::new([(x, y), (x + 1, y + 1)], color.filled())
        })
    )?;

    // Add a color bar
    chart.configure_series_labels().border_style(&BLACK).draw()?;
    
    let mut color_bar_chart = ChartBuilder::on(&root)
        .margin_left(700)
        .x_label_area_size(30)
        .y_label_area_size(40)
        .build_cartesian_2d(0..1, 0f64..1f64)?;

    color_bar_chart.draw_series(
        (0..100).map(|i| i as f64 / 100.0)
        .map(|y| {
            let color = HSLColor(240.0 * (1.0 - y), 0.7, 0.5);
            Rectangle::new([(0, y), (1, y + 0.01)], color.filled())
        })
    )?;

    root.present()?;
    println!("Visualization saved to {}", output_path);
    Ok(())
}
```

#### `src/main.rs` (CLI Entrypoint)

```rust
use clap::{Parser, Subcommand};
use anyhow::Result;

mod db;
mod models;
mod schema;
mod simulation;
mod visualization;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Run a new simulation and save the results
    Run {
        #[arg(short, long, default_value = "Test Run")]
        description: String,
        #[arg(short, long, default_value_t = 41)]
        grid_size: usize,
        #[arg(short, long, default_value_t = 1000)]
        steps: usize,
        #[arg(long, default_value_t = 0.71)]
        prandtl: f64,
        #[arg(long, default_value_t = 10000.0)]
        rayleigh: f64,
    },
    /// List all previous simulation runs
    List,
    /// Query a past simulation and generate a visualization
    Query {
        #[arg(short, long)]
        id: i32,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    let pool = db::establish_connection_pool();

    match &cli.command {
        Commands::Run { description, grid_size, steps, prandtl, rayleigh } => {
            println!("Starting new simulation...");

            // 1. Create a record for this simulation run
            let run = db::create_simulation_run(
                &pool,
                description,
                *grid_size as i32,
                *steps as i32,
                *prandtl,
                *rayleigh,
            )?;
            println!("Created simulation run with ID: {}", run.id);

            // 2. Setup and run the simulation
            let params = simulation::SimParameters {
                nx: *grid_size,
                ny: *grid_size,
                dt: 0.0001, // A small, stable time step
                pr: *prandtl,
                ra: *rayleigh,
            };
            let mut sim = simulation::Simulation::new(params);
            sim.run(*steps);

            // 3. Save the results to the database
            println!("Saving results to database...");
            db::save_simulation_results(&pool, run.id, &sim.state)?;
            println!("Results saved successfully.");

            // 4. Generate a visualization
            let output_file = format!("run_{}_temp.png", run.id);
            visualization::draw_temperature_map(&sim.state, &output_file)?;
        }
        Commands::List => {
            println!("Querying simulation runs from the database...");
            db::list_simulation_runs(&pool)?;
        }
        Commands::Query { id } => {
            println!("Querying results for run ID: {}", id);
            let state = db::get_simulation_results(&pool, *id)?;
            println!("Results retrieved. Generating visualization...");
            
            let output_file = format!("queried_run_{}_temp.png", id);
            visualization::draw_temperature_map(&state, &output_file)?;
        }
    }

    Ok(())
}
```
